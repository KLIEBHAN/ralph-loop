#!/bin/bash
#
# ralph - External Ralph loop with fresh context each iteration
#
# This implements the ORIGINAL Ralph Wiggum technique:
# https://ghuntley.com/ralph/
#
# Each iteration runs as a NEW CLI process with FRESH context.
# Previous work is only visible through files and git history.
#
# Supports: Claude Code, OpenAI Codex
#
# Usage:
#   ralph [OPTIONS] "Your prompt here"
#
# Options:
#   --cli <claude|codex>    CLI to use (default: claude)
#   --max-iterations, -n    Max iterations (default: 10)
#   --promise, -p           Completion promise (default: COMPLETE)
#   --help, -h              Show help
#
# Examples:
#   ralph "Build a REST API for todos"
#   ralph --cli codex "Fix the auth bug"
#   ralph -n 20 -p COMPLETE "Implement feature X"
#

set -euo pipefail

# Cleanup on interrupt
OUTPUT_FILE=""
cleanup() {
  [[ -n "$OUTPUT_FILE" && -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
}
trap cleanup EXIT INT TERM

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Progress bar function
progress_bar() {
  local current=$1
  local total=$2
  local width=20
  local filled=$((current * width / total))
  local empty=$((width - filled))
  local bar=""
  for ((j=0; j<filled; j++)); do bar+="â–ˆ"; done
  for ((j=0; j<empty; j++)); do bar+="â–‘"; done
  echo -n "[$bar] $current/$total"
}

# Format duration
format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  else
    local mins=$((seconds / 60))
    local secs=$((seconds % 60))
    echo "${mins}m ${secs}s"
  fi
}

# Default values
CLI="claude"
MAX_ITERATIONS=10
COMPLETION_PROMISE="COMPLETE"
PROMPT=""

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --cli)
      CLI="$2"
      shift 2
      ;;
    --max-iterations|-n)
      MAX_ITERATIONS="$2"
      shift 2
      ;;
    --promise|-p)
      COMPLETION_PROMISE="$2"
      shift 2
      ;;
    --help|-h)
      echo "Usage: ralph [OPTIONS] \"Your prompt\""
      echo ""
      echo "Options:"
      echo "  --cli <claude|codex>    CLI to use (default: claude)"
      echo "  --max-iterations, -n    Max iterations (default: 10)"
      echo "  --promise, -p           Completion promise (default: COMPLETE)"
      echo "  --help, -h              Show this help"
      echo ""
      echo "Examples:"
      echo "  ralph \"Build a REST API for todos\""
      echo "  ralph --cli codex \"Fix the auth bug\""
      echo "  ralph -n 20 -p COMPLETE \"Implement feature X\""
      exit 0
      ;;
    -*)
      echo -e "${RED}âŒ Error: Unknown option: $1${NC}"
      exit 1
      ;;
    *)
      PROMPT="$1"
      shift
      ;;
  esac
done

# Validate prompt
if [[ -z "$PROMPT" ]]; then
  echo -e "${RED}âŒ Error: No prompt provided${NC}"
  echo "  Run: ralph --help"
  exit 1
fi

# Validate CLI choice
if [[ "$CLI" != "claude" && "$CLI" != "codex" ]]; then
  echo -e "${RED}âŒ Error: --cli must be 'claude' or 'codex' (got: '$CLI')${NC}"
  exit 1
fi

# Validate max_iterations is numeric
if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
  echo -e "${RED}âŒ Error: --max-iterations must be a number (got: '$MAX_ITERATIONS')${NC}"
  exit 1
fi

# Check dependencies
if ! command -v "$CLI" &>/dev/null; then
  echo -e "${RED}âŒ Error: $CLI is required but not installed${NC}"
  exit 1
fi
if [[ "$CLI" == "claude" ]] && ! command -v jq &>/dev/null; then
  echo -e "${RED}âŒ Error: jq is required for Claude but not installed${NC}"
  echo "  Install with: brew install jq"
  exit 1
fi

# Build the full prompt with iteration context
build_prompt() {
  local iteration=$1
  cat <<EOF
$PROMPT

---
ğŸ”„ Ralph iteration $iteration/$MAX_ITERATIONS

INSTRUCTIONS:
- Check files and git history for previous work
- Continue from where the last iteration left off
- When the task is GENUINELY complete, output: <promise>$COMPLETION_PROMISE</promise>
- Do NOT output the promise unless the statement is TRUE
EOF
}

echo -e "${GREEN}ğŸ¿ï¸  Ralph Wiggum Loop - Fresh Context Edition${NC}"
echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
echo -e "  CLI:                ${YELLOW}$CLI${NC}"
echo -e "  Max iterations:     ${YELLOW}$MAX_ITERATIONS${NC}"
echo -e "  Completion promise: ${YELLOW}$COMPLETION_PROMISE${NC}"
echo -e "  Context:            ${GREEN}FRESH each iteration${NC}"
echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
echo ""

TOTAL_START_TIME=$(date +%s)

for i in $(seq 1 "$MAX_ITERATIONS"); do
  ITER_START_TIME=$(date +%s)
  ITER_START_DISPLAY=$(date +"%H:%M:%S")

  echo ""
  echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${YELLOW}ğŸ”„ Iteration $i/$MAX_ITERATIONS${NC}  ${DIM}started $ITER_START_DISPLAY${NC}"
  echo -e "${YELLOW}$(progress_bar "$i" "$MAX_ITERATIONS")${NC}"
  echo -e "${YELLOW}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  echo -e "${DIM}â”Œâ”€â”€â”€ $CLI output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

  # Build prompt for this iteration
  FULL_PROMPT=$(build_prompt "$i")

  # Run CLI with fresh context and stream output
  OUTPUT_FILE=$(mktemp)
  EXIT_CODE_FILE=$(mktemp)

  if [[ "$CLI" == "claude" ]]; then
    # Claude: Stream JSON output, parse to text in real-time
    while IFS= read -r line; do
      msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)

      case "$msg_type" in
        assistant)
          text=$(echo "$line" | jq -r '
            .message.content[]? |
            select(.type == "text") |
            .text // empty
          ' 2>/dev/null)
          if [[ -n "$text" ]]; then
            printf "%s\n" "$text"
            printf "%s\n" "$text" >> "$OUTPUT_FILE"
          fi

          tool=$(echo "$line" | jq -r '
            .message.content[]? |
            select(.type == "tool_use") |
            "  âš™ï¸  " + .name
          ' 2>/dev/null)
          if [[ -n "$tool" ]]; then
            echo -e "${BLUE}${tool}${NC}"
          fi
          ;;
        result)
          echo -e "${BLUE}  â†³ done${NC}"
          ;;
      esac
    done < <(claude -p --verbose --output-format stream-json --dangerously-skip-permissions -- "$FULL_PROMPT"; echo $? > "$EXIT_CODE_FILE")

  elif [[ "$CLI" == "codex" ]]; then
    # Codex: Use exec subcommand for non-interactive mode
    # --yolo: Full autonomy without safety checks (like Claude's --dangerously-skip-permissions)
    codex exec --yolo "$FULL_PROMPT" 2>&1 | tee "$OUTPUT_FILE"
    echo ${PIPESTATUS[0]} > "$EXIT_CODE_FILE"
  fi

  CLI_EXIT=$(cat "$EXIT_CODE_FILE")
  rm -f "$EXIT_CODE_FILE"

  # Close output section
  ITER_END_TIME=$(date +%s)
  ITER_DURATION=$((ITER_END_TIME - ITER_START_TIME))
  echo -e "${DIM}â””â”€â”€â”€ completed in $(format_duration $ITER_DURATION) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

  # Check result
  if [[ $CLI_EXIT -eq 0 ]]; then
    if grep -qF "<promise>$COMPLETION_PROMISE</promise>" "$OUTPUT_FILE"; then
      TOTAL_DURATION=$((ITER_END_TIME - TOTAL_START_TIME))
      echo ""
      echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
      echo -e "${GREEN}âœ… Task complete!${NC}"
      echo -e "${GREEN}   Promise: <promise>$COMPLETION_PROMISE</promise>${NC}"
      echo -e "${GREEN}   Iterations: $i${NC}"
      echo -e "${GREEN}   Total time: $(format_duration $TOTAL_DURATION)${NC}"
      echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
      rm "$OUTPUT_FILE"
      exit 0
    fi
  else
    echo -e "${RED}âš ï¸  $CLI exited with error (code: $CLI_EXIT), continuing...${NC}"
  fi

  rm "$OUTPUT_FILE"
done

TOTAL_END_TIME=$(date +%s)
TOTAL_DURATION=$((TOTAL_END_TIME - TOTAL_START_TIME))
echo ""
echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${RED}ğŸ›‘ Max iterations reached${NC}"
echo -e "${RED}   Iterations: $MAX_ITERATIONS${NC}"
echo -e "${RED}   Total time: $(format_duration $TOTAL_DURATION)${NC}"
echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
exit 1
