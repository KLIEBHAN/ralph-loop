#!/bin/bash
#
# ralph - AI agent loop with fresh context each iteration
#
# Implements the Ralph Wiggum technique: https://ghuntley.com/ralph/
# Each iteration starts a NEW process - previous work visible only via files/git.
#
# Usage: ralph [OPTIONS] "prompt"
# Run 'ralph --help' for details.

set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONSTANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Terminal colors (ANSI escape codes)
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# UI elements
readonly SEPARATOR="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
readonly PROGRESS_BAR_WIDTH=20

# Defaults (can be overridden via CLI flags)
readonly DEFAULT_CLI="claude"
readonly DEFAULT_MAX_ITERATIONS=10
readonly DEFAULT_PROMISE="COMPLETE"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEMP FILE MANAGEMENT
# Stores CLI output for promise detection and exit code capture
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OUTPUT_FILE=""
EXIT_CODE_FILE=""

create_temp_files() {
  OUTPUT_FILE=$(mktemp)
  EXIT_CODE_FILE=$(mktemp)
}

cleanup_temp_files() {
  [[ -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
  [[ -f "$EXIT_CODE_FILE" ]] && rm -f "$EXIT_CODE_FILE"
}

# Ensure cleanup on any exit (normal, error, or Ctrl+C)
trap cleanup_temp_files EXIT INT TERM

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FORMATTING HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Renders: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘] 3/10
render_progress_bar() {
  local current=$1 total=$2
  local filled=$((current * PROGRESS_BAR_WIDTH / total))
  local empty=$((PROGRESS_BAR_WIDTH - filled))

  printf "["
  printf 'â–ˆ%.0s' $(seq 1 $filled 2>/dev/null) || true
  printf 'â–‘%.0s' $(seq 1 $empty 2>/dev/null) || true
  printf "] %d/%d" "$current" "$total"
}

# Converts seconds to "45s" or "2m 30s"
format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  else
    echo "$((seconds / 60))m $((seconds % 60))s"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UI OUTPUT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_help() {
  cat << 'EOF'
Usage: ralph [OPTIONS] "Your prompt"

Options:
  --cli <claude|codex>    AI CLI to use (default: claude)
  -n, --max-iterations N  Max iterations (default: 10)
  -p, --promise TEXT      Completion signal (default: COMPLETE)
  --prd <file>            PRD file to validate (rejects if "## Offen" not empty)
  -h, --help              Show this help

Examples:
  # Basic usage
  ralph "Build a REST API for todos"

  # With iteration limit
  ralph -n 20 "Implement feature X"

  # PRD-based workflow (recommended for projects)
  ralph --prd plans/prd.md "Read plans/prd.md and work on the next feature"

  # Custom completion signal
  ralph -p "ALL TESTS PASS" "Fix the failing tests"

  # Combined options
  ralph -n 50 --prd plans/prd.md "Complete all features in the PRD"

Note: Options must come BEFORE the prompt. Wrong: ralph "prompt" 10
EOF
}

print_header() {
  echo -e "${GREEN}ğŸ¿ï¸  Ralph Loop${RESET}"
  echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
  echo -e "  CLI:      ${YELLOW}$CLI${RESET}"
  echo -e "  Max:      ${YELLOW}$MAX_ITERATIONS${RESET} iterations"
  echo -e "  Promise:  ${YELLOW}$PROMISE${RESET}"
  [[ -n "$PRD_FILE" ]] && echo -e "  PRD:      ${YELLOW}$PRD_FILE${RESET} (validates completion)"
  echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_iteration_start() {
  local iteration=$1 timestamp=$2
  echo ""
  echo -e "${YELLOW}${SEPARATOR}${RESET}"
  echo -e "${YELLOW}ğŸ”„ Iteration $iteration/$MAX_ITERATIONS${RESET}  ${DIM}started $timestamp${RESET}"
  echo -e "${YELLOW}$(render_progress_bar "$iteration" "$MAX_ITERATIONS")${RESET}"
  echo -e "${YELLOW}${SEPARATOR}${RESET}"
  echo ""
  echo -e "${DIM}â”Œâ”€â”€â”€ $CLI output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_iteration_end() {
  local duration=$1
  echo -e "${DIM}â””â”€â”€â”€ completed in $(format_duration "$duration") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_success() {
  local iterations=$1 duration=$2
  echo ""
  echo -e "${GREEN}${SEPARATOR}${RESET}"
  echo -e "${GREEN}âœ… Task complete!${RESET}"
  echo -e "${GREEN}   Iterations:  $iterations${RESET}"
  echo -e "${GREEN}   Total time:  $(format_duration "$duration")${RESET}"
  echo -e "${GREEN}${SEPARATOR}${RESET}"
}

print_exhausted() {
  local duration=$1
  echo ""
  echo -e "${RED}${SEPARATOR}${RESET}"
  echo -e "${RED}ğŸ›‘ Max iterations reached${RESET}"
  echo -e "${RED}   Iterations:  $MAX_ITERATIONS${RESET}"
  echo -e "${RED}   Total time:  $(format_duration "$duration")${RESET}"
  echo -e "${RED}${SEPARATOR}${RESET}"
}

# Semantic output helpers
print_error() { echo -e "${RED}âŒ Error: $1${RESET}" >&2; }
print_warning() { echo -e "${YELLOW}âš ï¸  $1${RESET}"; }
print_info() { echo -e "${DIM}   $1${RESET}" >&2; }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INPUT VALIDATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate_args() {
  if [[ -z "$PROMPT" ]]; then
    print_error "No prompt provided"
    echo "  Run: ralph --help" >&2
    exit 1
  fi

  if [[ "$CLI" != "claude" && "$CLI" != "codex" ]]; then
    print_error "--cli must be 'claude' or 'codex' (got: '$CLI')"
    exit 1
  fi

  if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]] || [[ "$MAX_ITERATIONS" -eq 0 ]]; then
    print_error "--max-iterations must be positive (got: '$MAX_ITERATIONS')"
    exit 1
  fi

  if [[ -z "$PROMISE" ]]; then
    print_error "--promise cannot be empty"
    exit 1
  fi

  if [[ -n "$PRD_FILE" && ! -f "$PRD_FILE" ]]; then
    print_error "PRD file not found: $PRD_FILE"
    exit 1
  fi
}

check_dependencies() {
  if ! command -v "$CLI" &>/dev/null; then
    print_error "$CLI is required but not installed"
    exit 1
  fi

  # Claude streams JSON that requires jq for parsing
  if [[ "$CLI" == "claude" ]] && ! command -v jq &>/dev/null; then
    print_error "jq required for Claude (brew install jq)"
    exit 1
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRD VALIDATION
# Prevents premature completion by checking actual PRD state
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

count_open_items() {
  local file=$1
  [[ ! -f "$file" ]] && { echo "0"; return; }
  # Count list items (lines starting with "- ") between "## Offen" and next heading
  # Note: grep -c outputs "0" on no match but exits 1; || true prevents exit without adding output
  sed -n '/^## Offen/,/^## /p' "$file" | grep -c "^- " 2>/dev/null || true
}

prd_allows_completion() {
  [[ -z "$PRD_FILE" ]] && return 0  # No PRD = no validation needed

  local open_count
  open_count=$(count_open_items "$PRD_FILE")

  if [[ "$open_count" -gt 0 ]]; then
    print_warning "Completion rejected: PRD has $open_count open item(s)"
    print_info "File: $PRD_FILE"
    return 1
  fi
  return 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROMPT CONSTRUCTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Wraps user prompt with loop instructions
# Note: Iteration number omitted intentionally - prevents rushing behavior
build_prompt() {
  local script_dir template_file template
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  template_file="${script_dir}/prompt.md"

  if [[ ! -f "$template_file" ]]; then
    print_error "prompt.md not found: $template_file"
    return 1
  fi

  template=$(<"$template_file")
  template=${template//\$PROMPT/$PROMPT}
  template=${template//\$PROMISE/$PROMISE}
  printf "\n\n%s\n" "$template"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI EXECUTION
# Each CLI has different output formats requiring different handling
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Extracts and displays text from Claude's JSON stream
parse_claude_message() {
  local line=$1
  local msg_type
  msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)

  case "$msg_type" in
    assistant)
      # Display text content
      local text
      text=$(echo "$line" | jq -r '.message.content[]? | select(.type == "text") | .text // empty' 2>/dev/null)
      if [[ -n "$text" ]]; then
        printf "%s\n" "$text"
        printf "%s\n" "$text" >> "$OUTPUT_FILE"
      fi

      # Show tool calls for visual feedback
      local tool
      tool=$(echo "$line" | jq -r '.message.content[]? | select(.type == "tool_use") | .name // empty' 2>/dev/null)
      [[ -n "$tool" ]] && echo -e "${BLUE}  âš™ï¸  ${tool}${RESET}"
      ;;
    result)
      echo -e "${BLUE}  â†³ done${RESET}"
      ;;
  esac
}

execute_claude() {
  local prompt=$1
  # Process substitution captures exit code separately from stream
  while IFS= read -r line; do
    parse_claude_message "$line"
  done < <(
    claude -p --verbose --output-format stream-json --dangerously-skip-permissions -- "$prompt"
    echo $? > "$EXIT_CODE_FILE"
  )
}

execute_codex() {
  local prompt=$1
  codex exec --yolo "$prompt" 2>&1 | tee "$OUTPUT_FILE"
  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
}

execute_cli() {
  local prompt=$1
  if [[ "$CLI" == "claude" ]]; then
    execute_claude "$prompt"
  else
    execute_codex "$prompt"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPLETION DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

output_has_promise() {
  grep -qF "<promise>$PROMISE</promise>" "$OUTPUT_FILE"
}

cli_succeeded() {
  [[ "$(cat "$EXIT_CODE_FILE")" -eq 0 ]]
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ITERATION LOGIC
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Returns 0 if task completed, 1 to continue iterating
run_iteration() {
  local iteration=$1
  local start_time end_time result=1
  local prompt

  start_time=$(date +%s)
  print_iteration_start "$iteration" "$(date +%H:%M:%S)"

  create_temp_files
  prompt="$(build_prompt)"
  execute_cli "$prompt"

  end_time=$(date +%s)
  print_iteration_end "$((end_time - start_time))"

  # Determine result
  if ! cli_succeeded; then
    print_warning "$CLI exited with error, continuing..."
  elif output_has_promise && prd_allows_completion; then
    result=0
  fi

  cleanup_temp_files
  return $result
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ARGUMENT PARSING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CLI="$DEFAULT_CLI"
MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
PROMISE="$DEFAULT_PROMISE"
PRD_FILE=""
PROMPT=""
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cli)               CLI="$2"; shift 2 ;;
    --max-iterations|-n) MAX_ITERATIONS="$2"; shift 2 ;;
    --promise|-p)        PROMISE="$2"; shift 2 ;;
    --prd)               PRD_FILE="$2"; shift 2 ;;
    --help|-h)           print_help; exit 0 ;;
    -*)                  print_error "Unknown option: $1"; exit 1 ;;
    *)
      # First positional arg = prompt, rest = extra args (likely user error)
      if [[ -z "$PROMPT" ]]; then
        PROMPT="$1"
      else
        EXTRA_ARGS+=("$1")
      fi
      shift
      ;;
  esac
done

# Help users who pass arguments in wrong order
warn_extra_args() {
  [[ ${#EXTRA_ARGS[@]} -eq 0 ]] && return

  print_warning "Extra arguments ignored: ${EXTRA_ARGS[*]}"
  print_info "Did you mean to use flags?"

  for arg in "${EXTRA_ARGS[@]}"; do
    # Suggest appropriate flag based on argument pattern
    if [[ "$arg" =~ ^[0-9]+$ ]]; then
      print_info "â€¢ For iterations: -n $arg"
    elif [[ "$arg" =~ ^(COMPLETE|DONE|FINISHED|READY)$ ]]; then
      print_info "â€¢ For promise: -p $arg"
    elif [[ -f "$arg" ]] || [[ "$arg" =~ \.(md|txt)$ ]]; then
      print_info "â€¢ For PRD: --prd $arg"
    fi
  done
  echo "" >&2
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
  warn_extra_args
  validate_args
  check_dependencies
  print_header

  local start_time
  start_time=$(date +%s)

  for i in $(seq 1 "$MAX_ITERATIONS"); do
    if run_iteration "$i"; then
      print_success "$i" "$(($(date +%s) - start_time))"
      exit 0
    fi
  done

  print_exhausted "$(($(date +%s) - start_time))"
  exit 1
}

main
