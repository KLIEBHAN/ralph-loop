#!/bin/bash
#
# ralph - AI agent loop with fresh context each iteration
#
# Implements the Ralph Wiggum technique: https://ghuntley.com/ralph/
# Each iteration starts a NEW process - previous work visible only via files/git.
#
# Usage: ralph [OPTIONS] "prompt"
# Run 'ralph --help' for details.

set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONSTANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Terminal colors (ANSI escape codes)
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly DIM='\033[2m'
readonly RESET='\033[0m'

# UI elements
readonly SEPARATOR="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
readonly PROGRESS_BAR_WIDTH=20

# Defaults (can be overridden via CLI flags)
readonly DEFAULT_CLI="claude"
readonly DEFAULT_MAX_ITERATIONS=10
readonly DEFAULT_PROMISE="COMPLETE"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEMP FILE MANAGEMENT
# Stores CLI output for promise detection and exit code capture
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OUTPUT_FILE=""
EXIT_CODE_FILE=""

create_temp_files() {
  OUTPUT_FILE=$(mktemp)
  EXIT_CODE_FILE=$(mktemp)
}

cleanup_temp_files() {
  [[ -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
  [[ -f "$EXIT_CODE_FILE" ]] && rm -f "$EXIT_CODE_FILE"
}

# Ensure cleanup on any exit (normal, error, or Ctrl+C)
trap cleanup_temp_files EXIT INT TERM

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FORMATTING HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Renders: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘] 3/10
render_progress_bar() {
  local current=$1 total=$2
  local filled=$((current * PROGRESS_BAR_WIDTH / total))
  local empty=$((PROGRESS_BAR_WIDTH - filled))

  printf "["
  printf 'â–ˆ%.0s' $(seq 1 $filled 2>/dev/null) || true
  printf 'â–‘%.0s' $(seq 1 $empty 2>/dev/null) || true
  printf "] %d/%d" "$current" "$total"
}

# Converts seconds to "45s" or "2m 30s"
format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  else
    echo "$((seconds / 60))m $((seconds % 60))s"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UI OUTPUT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_help() {
  cat << 'EOF'
Usage: ralph [OPTIONS] "Your prompt"

Options:
  --cli <claude|codex>    AI CLI to use (default: claude)
  -n, --max-iterations N  Max iterations (default: 10)
  -p, --promise TEXT      Completion signal (default: COMPLETE)
  --prd <file>            PRD file to validate (rejects if "## Offen" not empty)
  -h, --help              Show this help

Examples:
  # Basic usage
  ralph "Build a REST API for todos"

  # With iteration limit
  ralph -n 20 "Implement feature X"

  # PRD-based workflow (recommended for projects)
  ralph --prd plans/prd.md "Read plans/prd.md and work on the next feature"

  # Custom completion signal
  ralph -p "ALL TESTS PASS" "Fix the failing tests"

  # Combined options
  ralph -n 50 --prd plans/prd.md "Complete all features in the PRD"

Note: Options must come BEFORE the prompt. Wrong: ralph "prompt" 10
EOF
}

print_header() {
  echo -e "${GREEN}ğŸ¿ï¸  Ralph Loop${RESET}"
  echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
  echo -e "  CLI:      ${YELLOW}$CLI${RESET}"
  echo -e "  Max:      ${YELLOW}$MAX_ITERATIONS${RESET} iterations"
  echo -e "  Promise:  ${YELLOW}$PROMISE${RESET}"
  [[ -n "$PRD_FILE" ]] && echo -e "  PRD:      ${YELLOW}$PRD_FILE${RESET} (validates completion)"
  echo -e "${BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_iteration_start() {
  local iteration=$1 timestamp=$2
  echo ""
  echo -e "${YELLOW}${SEPARATOR}${RESET}"
  echo -e "${YELLOW}ğŸ”„ Iteration $iteration/$MAX_ITERATIONS${RESET}  ${DIM}started $timestamp${RESET}"
  echo -e "${YELLOW}$(render_progress_bar "$iteration" "$MAX_ITERATIONS")${RESET}"
  echo -e "${YELLOW}${SEPARATOR}${RESET}"
  echo ""
  echo -e "${DIM}â”Œâ”€â”€â”€ $CLI output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_iteration_end() {
  local duration=$1
  echo -e "${DIM}â””â”€â”€â”€ completed in $(format_duration "$duration") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
}

print_success() {
  local iterations=$1 duration=$2
  echo ""
  echo -e "${GREEN}${SEPARATOR}${RESET}"
  echo -e "${GREEN}âœ… Task complete!${RESET}"
  echo -e "${GREEN}   Iterations:  $iterations${RESET}"
  echo -e "${GREEN}   Total time:  $(format_duration "$duration")${RESET}"
  echo -e "${GREEN}${SEPARATOR}${RESET}"
}

print_exhausted() {
  local duration=$1
  echo ""
  echo -e "${RED}${SEPARATOR}${RESET}"
  echo -e "${RED}ğŸ›‘ Max iterations reached${RESET}"
  echo -e "${RED}   Iterations:  $MAX_ITERATIONS${RESET}"
  echo -e "${RED}   Total time:  $(format_duration "$duration")${RESET}"
  echo -e "${RED}${SEPARATOR}${RESET}"
}

# Semantic output helpers
print_error() { echo -e "${RED}âŒ Error: $1${RESET}" >&2; }
print_warning() { echo -e "${YELLOW}âš ï¸  $1${RESET}"; }
print_info() { echo -e "${DIM}   $1${RESET}" >&2; }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INPUT VALIDATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate_args() {
  [[ -z "$PROMPT" ]] && { print_error "No prompt provided"; echo "  Run: ralph --help" >&2; exit 1; }
  [[ "$CLI" != "claude" && "$CLI" != "codex" ]] && { print_error "--cli must be 'claude' or 'codex' (got: '$CLI')"; exit 1; }
  ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]] || [[ "$MAX_ITERATIONS" -eq 0 ]] && { print_error "--max-iterations must be positive (got: '$MAX_ITERATIONS')"; exit 1; }
  [[ -z "$PROMISE" ]] && { print_error "--promise cannot be empty"; exit 1; }
  [[ -n "$PRD_FILE" && ! -f "$PRD_FILE" ]] && { print_error "PRD file not found: $PRD_FILE"; exit 1; }
}

check_dependencies() {
  ! command -v "$CLI" &>/dev/null && { print_error "$CLI is required but not installed"; exit 1; }
  # Claude streams JSON that requires jq for parsing
  [[ "$CLI" == "claude" ]] && ! command -v jq &>/dev/null && { print_error "jq required for Claude (brew install jq)"; exit 1; }
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRD VALIDATION
# Prevents premature completion by checking actual PRD state
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

count_open_items() {
  local file=$1
  [[ ! -f "$file" ]] && { echo "0"; return; }
  # Count list items (lines starting with "- ") between "## Offen" and next heading
  sed -n '/^## Offen/,/^## /p' "$file" | grep -c "^- " 2>/dev/null || echo "0"
}

prd_allows_completion() {
  [[ -z "$PRD_FILE" ]] && return 0  # No PRD = no validation needed

  local open_count
  open_count=$(count_open_items "$PRD_FILE")

  if [[ "$open_count" -gt 0 ]]; then
    print_warning "Completion rejected: PRD has $open_count open item(s)"
    print_info "File: $PRD_FILE"
    return 1
  fi
  return 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROMPT CONSTRUCTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Wraps user prompt with loop instructions
# Note: Iteration number omitted intentionally - prevents rushing behavior
build_prompt() {
  cat <<EOF
$PROMPT

---
ğŸ”„ Ralph Loop (fresh context)

INSTRUCTIONS:
- Check files and git history for previous work
- Continue from where you left off
- When GENUINELY complete, output: <promise>$PROMISE</promise>
- Do NOT output the promise unless truly done
EOF
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI EXECUTION
# Each CLI has different output formats requiring different handling
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Extracts and displays text from Claude's JSON stream
parse_claude_message() {
  local line=$1
  local msg_type
  msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)

  case "$msg_type" in
    assistant)
      # Display text content
      local text
      text=$(echo "$line" | jq -r '.message.content[]? | select(.type == "text") | .text // empty' 2>/dev/null)
      if [[ -n "$text" ]]; then
        printf "%s\n" "$text"
        printf "%s\n" "$text" >> "$OUTPUT_FILE"
      fi

      # Show tool calls for visual feedback
      local tool
      tool=$(echo "$line" | jq -r '.message.content[]? | select(.type == "tool_use") | .name // empty' 2>/dev/null)
      [[ -n "$tool" ]] && echo -e "${BLUE}  âš™ï¸  ${tool}${RESET}"
      ;;
    result)
      echo -e "${BLUE}  â†³ done${RESET}"
      ;;
  esac
}

execute_claude() {
  local prompt=$1
  # Process substitution captures exit code separately from stream
  while IFS= read -r line; do
    parse_claude_message "$line"
  done < <(
    claude -p --verbose --output-format stream-json --dangerously-skip-permissions -- "$prompt"
    echo $? > "$EXIT_CODE_FILE"
  )
}

execute_codex() {
  local prompt=$1
  codex exec --yolo "$prompt" 2>&1 | tee "$OUTPUT_FILE"
  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
}

execute_cli() {
  local prompt=$1
  [[ "$CLI" == "claude" ]] && execute_claude "$prompt" || execute_codex "$prompt"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPLETION DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

output_has_promise() {
  grep -qF "<promise>$PROMISE</promise>" "$OUTPUT_FILE"
}

cli_succeeded() {
  [[ "$(cat "$EXIT_CODE_FILE")" -eq 0 ]]
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ITERATION LOGIC
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Returns 0 if task completed, 1 to continue iterating
run_iteration() {
  local iteration=$1
  local start_time end_time

  start_time=$(date +%s)
  print_iteration_start "$iteration" "$(date +%H:%M:%S)"

  create_temp_files
  execute_cli "$(build_prompt)"

  end_time=$(date +%s)
  print_iteration_end "$((end_time - start_time))"

  # Handle CLI errors gracefully
  if ! cli_succeeded; then
    print_warning "$CLI exited with error, continuing..."
    cleanup_temp_files
    return 1
  fi

  # Check completion: promise present AND PRD allows it
  if output_has_promise && prd_allows_completion; then
    cleanup_temp_files
    return 0
  fi

  cleanup_temp_files
  return 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ARGUMENT PARSING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CLI="$DEFAULT_CLI"
MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
PROMISE="$DEFAULT_PROMISE"
PRD_FILE=""
PROMPT=""
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cli)               CLI="$2"; shift 2 ;;
    --max-iterations|-n) MAX_ITERATIONS="$2"; shift 2 ;;
    --promise|-p)        PROMISE="$2"; shift 2 ;;
    --prd)               PRD_FILE="$2"; shift 2 ;;
    --help|-h)           print_help; exit 0 ;;
    -*)                  print_error "Unknown option: $1"; exit 1 ;;
    *)                   [[ -z "$PROMPT" ]] && PROMPT="$1" || EXTRA_ARGS+=("$1"); shift ;;
  esac
done

# Help users who pass arguments in wrong order
warn_extra_args() {
  [[ ${#EXTRA_ARGS[@]} -eq 0 ]] && return

  print_warning "Extra arguments ignored: ${EXTRA_ARGS[*]}"
  print_info "Did you mean to use flags?"

  for arg in "${EXTRA_ARGS[@]}"; do
    [[ "$arg" =~ ^[0-9]+$ ]] && print_info "â€¢ For iterations: -n $arg"
    [[ "$arg" =~ ^(COMPLETE|DONE|FINISHED|READY)$ ]] && print_info "â€¢ For promise: -p $arg"
    { [[ -f "$arg" ]] || [[ "$arg" =~ \.(md|txt)$ ]]; } && print_info "â€¢ For PRD: --prd $arg"
  done
  echo "" >&2
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
  warn_extra_args
  validate_args
  check_dependencies
  print_header

  local start_time=$(($(date +%s)))

  for i in $(seq 1 "$MAX_ITERATIONS"); do
    if run_iteration "$i"; then
      print_success "$i" "$(($(date +%s) - start_time))"
      exit 0
    fi
  done

  print_exhausted "$(($(date +%s) - start_time))"
  exit 1
}

main
