#!/bin/bash
#
# ralph - AI agent loop with fresh context each iteration
#
# Implements the Ralph Wiggum technique: https://ghuntley.com/ralph/
# Each iteration starts a NEW process - previous work visible only via files/git.
#
# Usage: ralph [OPTIONS] "prompt"
# Run 'ralph --help' for details.

set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Terminal colors
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_DIM='\033[2m'
readonly COLOR_RESET='\033[0m'

# Visual elements
readonly LINE="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Defaults
DEFAULT_CLI="claude"
DEFAULT_MAX_ITERATIONS=10
DEFAULT_PROMISE="COMPLETE"
DEFAULT_PRD=""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Cleanup temp files on exit/interrupt
cleanup() {
  [[ -n "${OUTPUT_FILE:-}" && -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
  [[ -n "${EXIT_CODE_FILE:-}" && -f "$EXIT_CODE_FILE" ]] && rm -f "$EXIT_CODE_FILE"
}
trap cleanup EXIT INT TERM

# Render progress bar: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘] 3/10
render_progress_bar() {
  local current=$1 total=$2 width=20
  local filled=$((current * width / total))
  local empty=$((width - filled))

  printf "["
  printf 'â–ˆ%.0s' $(seq 1 $filled 2>/dev/null) || true
  printf 'â–‘%.0s' $(seq 1 $empty 2>/dev/null) || true
  printf "] %d/%d" "$current" "$total"
}

# Format seconds as human-readable duration
format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  else
    echo "$((seconds / 60))m $((seconds % 60))s"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UI OUTPUT FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_help() {
  cat << 'EOF'
Usage: ralph [OPTIONS] "Your prompt"

Options:
  --cli <claude|codex>    AI CLI to use (default: claude)
  --max-iterations, -n    Max iterations (default: 10)
  --promise, -p           Completion signal (default: COMPLETE)
  --prd <file>            PRD file to validate (rejects completion if "Offen" not empty)
  --help, -h              Show this help

Examples:
  ralph "Build a REST API for todos"
  ralph --cli codex "Fix the auth bug"
  ralph -n 20 -p DONE "Implement feature X"
  ralph --prd plans/prd.md "Work on the next feature from PRD"
EOF
}

show_header() {
  echo -e "${COLOR_GREEN}ğŸ¿ï¸  Ralph Loop${COLOR_RESET}"
  echo -e "${COLOR_BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
  echo -e "  CLI:      ${COLOR_YELLOW}$CLI${COLOR_RESET}"
  echo -e "  Max:      ${COLOR_YELLOW}$MAX_ITERATIONS${COLOR_RESET} iterations"
  echo -e "  Promise:  ${COLOR_YELLOW}$PROMISE${COLOR_RESET}"
  if [[ -n "$PRD_FILE" ]]; then
    echo -e "  PRD:      ${COLOR_YELLOW}$PRD_FILE${COLOR_RESET} (validates completion)"
  fi
  echo -e "${COLOR_BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

show_iteration_start() {
  local iteration=$1 start_time=$2
  echo ""
  echo -e "${COLOR_YELLOW}${LINE}${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}ğŸ”„ Iteration $iteration/$MAX_ITERATIONS${COLOR_RESET}  ${COLOR_DIM}started $start_time${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}$(render_progress_bar "$iteration" "$MAX_ITERATIONS")${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}${LINE}${COLOR_RESET}"
  echo ""
  echo -e "${COLOR_DIM}â”Œâ”€â”€â”€ $CLI output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

show_iteration_end() {
  local duration=$1
  echo -e "${COLOR_DIM}â””â”€â”€â”€ completed in $(format_duration "$duration") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

show_success() {
  local iterations=$1 total_duration=$2
  echo ""
  echo -e "${COLOR_GREEN}${LINE}${COLOR_RESET}"
  echo -e "${COLOR_GREEN}âœ… Task complete!${COLOR_RESET}"
  echo -e "${COLOR_GREEN}   Iterations:  $iterations${COLOR_RESET}"
  echo -e "${COLOR_GREEN}   Total time:  $(format_duration "$total_duration")${COLOR_RESET}"
  echo -e "${COLOR_GREEN}${LINE}${COLOR_RESET}"
}

show_max_iterations_reached() {
  local total_duration=$1
  echo ""
  echo -e "${COLOR_RED}${LINE}${COLOR_RESET}"
  echo -e "${COLOR_RED}ğŸ›‘ Max iterations reached${COLOR_RESET}"
  echo -e "${COLOR_RED}   Iterations:  $MAX_ITERATIONS${COLOR_RESET}"
  echo -e "${COLOR_RED}   Total time:  $(format_duration "$total_duration")${COLOR_RESET}"
  echo -e "${COLOR_RED}${LINE}${COLOR_RESET}"
}

show_error() {
  echo -e "${COLOR_RED}âŒ Error: $1${COLOR_RESET}" >&2
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VALIDATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate_inputs() {
  if [[ -z "$PROMPT" ]]; then
    show_error "No prompt provided"
    echo "  Run: ralph --help" >&2
    exit 1
  fi

  if [[ "$CLI" != "claude" && "$CLI" != "codex" ]]; then
    show_error "--cli must be 'claude' or 'codex' (got: '$CLI')"
    exit 1
  fi

  if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
    show_error "--max-iterations must be a number (got: '$MAX_ITERATIONS')"
    exit 1
  fi

  if [[ -n "$PRD_FILE" && ! -f "$PRD_FILE" ]]; then
    show_error "PRD file not found: $PRD_FILE"
    exit 1
  fi
}

# Count open items in PRD's "## Offen" section
# Returns the count (0 if section empty or not found)
count_prd_open_items() {
  local prd_file=$1

  if [[ ! -f "$prd_file" ]]; then
    echo "0"
    return
  fi

  # Extract lines between "## Offen" and next "##", count list items (lines starting with "- ")
  sed -n '/^## Offen/,/^## /p' "$prd_file" | grep -c "^- " 2>/dev/null || echo "0"
}

# Validate PRD completion (returns 0 if valid, 1 if rejected)
validate_prd_completion() {
  if [[ -z "$PRD_FILE" ]]; then
    return 0  # No PRD validation requested
  fi

  local open_count
  open_count=$(count_prd_open_items "$PRD_FILE")

  if [[ "$open_count" -gt 0 ]]; then
    echo -e "${COLOR_RED}âš ï¸  Completion rejected: PRD has $open_count open item(s)${COLOR_RESET}"
    echo -e "${COLOR_DIM}   File: $PRD_FILE${COLOR_RESET}"
    return 1
  fi

  return 0
}

check_dependencies() {
  if ! command -v "$CLI" &>/dev/null; then
    show_error "$CLI is required but not installed"
    exit 1
  fi

  # Claude requires jq for JSON stream parsing
  if [[ "$CLI" == "claude" ]] && ! command -v jq &>/dev/null; then
    show_error "jq is required for Claude (brew install jq)"
    exit 1
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROMPT BUILDING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Append iteration context to help AI track progress
build_iteration_prompt() {
  local iteration=$1
  cat <<EOF
$PROMPT

---
ğŸ”„ Ralph iteration $iteration/$MAX_ITERATIONS

INSTRUCTIONS:
- Check files and git history for previous work
- Continue from where the last iteration left off
- When GENUINELY complete, output: <promise>$PROMISE</promise>
- Do NOT output the promise unless the statement is TRUE
EOF
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Run Claude with streaming JSON output, parsed to readable text
run_claude() {
  local prompt=$1

  while IFS= read -r line; do
    local msg_type
    msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)

    case "$msg_type" in
      assistant)
        # Extract and display text content
        local text
        text=$(echo "$line" | jq -r '
          .message.content[]? | select(.type == "text") | .text // empty
        ' 2>/dev/null)
        [[ -n "$text" ]] && { printf "%s\n" "$text"; printf "%s\n" "$text" >> "$OUTPUT_FILE"; }

        # Show tool calls (visual feedback that work is happening)
        local tool
        tool=$(echo "$line" | jq -r '
          .message.content[]? | select(.type == "tool_use") | "  âš™ï¸  " + .name
        ' 2>/dev/null)
        [[ -n "$tool" ]] && echo -e "${COLOR_BLUE}${tool}${COLOR_RESET}"
        ;;
      result)
        echo -e "${COLOR_BLUE}  â†³ done${COLOR_RESET}"
        ;;
    esac
  done < <(
    claude -p --verbose --output-format stream-json --dangerously-skip-permissions -- "$prompt"
    echo $? > "$EXIT_CODE_FILE"
  )
}

# Run Codex with full autonomy
run_codex() {
  local prompt=$1
  codex exec --yolo "$prompt" 2>&1 | tee "$OUTPUT_FILE"
  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ARGUMENT PARSING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CLI="$DEFAULT_CLI"
MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
PROMISE="$DEFAULT_PROMISE"
PRD_FILE="$DEFAULT_PRD"
PROMPT=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cli)            CLI="$2"; shift 2 ;;
    --max-iterations|-n) MAX_ITERATIONS="$2"; shift 2 ;;
    --promise|-p)     PROMISE="$2"; shift 2 ;;
    --prd)            PRD_FILE="$2"; shift 2 ;;
    --help|-h)        show_help; exit 0 ;;
    -*)               show_error "Unknown option: $1"; exit 1 ;;
    *)                PROMPT="$1"; shift ;;
  esac
done

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN LOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate_inputs
check_dependencies
show_header

total_start_time=$(date +%s)

for iteration in $(seq 1 "$MAX_ITERATIONS"); do
  iter_start_time=$(date +%s)

  show_iteration_start "$iteration" "$(date +%H:%M:%S)"

  # Prepare temp files for this iteration
  OUTPUT_FILE=$(mktemp)
  EXIT_CODE_FILE=$(mktemp)

  # Run the appropriate CLI
  full_prompt=$(build_iteration_prompt "$iteration")
  if [[ "$CLI" == "claude" ]]; then
    run_claude "$full_prompt"
  else
    run_codex "$full_prompt"
  fi

  # Calculate iteration duration
  iter_end_time=$(date +%s)
  iter_duration=$((iter_end_time - iter_start_time))
  show_iteration_end "$iter_duration"

  # Check for completion or errors
  cli_exit_code=$(cat "$EXIT_CODE_FILE")

  if [[ "$cli_exit_code" -eq 0 ]]; then
    # Success - check if task is complete
    if grep -qF "<promise>$PROMISE</promise>" "$OUTPUT_FILE"; then
      # Validate against PRD if specified
      if validate_prd_completion; then
        total_duration=$((iter_end_time - total_start_time))
        show_success "$iteration" "$total_duration"
        exit 0
      fi
      # PRD validation failed - continue to next iteration
    fi
  else
    echo -e "${COLOR_RED}âš ï¸  $CLI exited with error (code: $cli_exit_code), continuing...${COLOR_RESET}"
  fi

  rm -f "$OUTPUT_FILE" "$EXIT_CODE_FILE"
done

# Loop exhausted without completion
total_duration=$(($(date +%s) - total_start_time))
show_max_iterations_reached "$total_duration"
exit 1
