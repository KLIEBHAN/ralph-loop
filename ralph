#!/bin/bash
#
# ralph - AI agent loop with fresh context each iteration
#
# Implements the Ralph Wiggum technique: https://ghuntley.com/ralph/
# Each iteration starts a NEW process - previous work visible only via files/git.
#
# Usage: ralph [OPTIONS] "prompt"
# Run 'ralph --help' for details.

set -euo pipefail

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONSTANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Terminal colors (ANSI escape codes)
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_DIM='\033[2m'
readonly COLOR_RESET='\033[0m'

# UI elements
readonly SEPARATOR="â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
readonly PROGRESS_BAR_WIDTH=20

# Defaults (can be overridden via CLI flags)
readonly DEFAULT_CLI="claude"
readonly DEFAULT_MAX_ITERATIONS=10
readonly DEFAULT_PROMISE="COMPLETE"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TEMP FILE MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Global temp files (set per iteration, cleaned up on exit)
OUTPUT_FILE=""
EXIT_CODE_FILE=""

cleanup_temp_files() {
  [[ -n "$OUTPUT_FILE" && -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
  [[ -n "$EXIT_CODE_FILE" && -f "$EXIT_CODE_FILE" ]] && rm -f "$EXIT_CODE_FILE"
}

# Ensure cleanup runs on any exit (normal, error, or interrupt)
trap cleanup_temp_files EXIT INT TERM

create_temp_files() {
  OUTPUT_FILE=$(mktemp)
  EXIT_CODE_FILE=$(mktemp)
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FORMATTING HELPERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Renders: [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘] 3/10
render_progress_bar() {
  local current=$1 total=$2
  local filled=$((current * PROGRESS_BAR_WIDTH / total))
  local empty=$((PROGRESS_BAR_WIDTH - filled))

  printf "["
  printf 'â–ˆ%.0s' $(seq 1 $filled 2>/dev/null) || true
  printf 'â–‘%.0s' $(seq 1 $empty 2>/dev/null) || true
  printf "] %d/%d" "$current" "$total"
}

# Converts seconds to human-readable format: "45s" or "2m 30s"
format_duration() {
  local seconds=$1
  if ((seconds < 60)); then
    echo "${seconds}s"
  else
    echo "$((seconds / 60))m $((seconds % 60))s"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UI OUTPUT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_help() {
  cat << 'EOF'
Usage: ralph [OPTIONS] "Your prompt"

Options:
  --cli <claude|codex>    AI CLI to use (default: claude)
  -n, --max-iterations N  Max iterations (default: 10)
  -p, --promise TEXT      Completion signal (default: COMPLETE)
  --prd <file>            PRD file to validate (rejects if "## Offen" not empty)
  -h, --help              Show this help

Examples:
  # Basic usage
  ralph "Build a REST API for todos"

  # With iteration limit
  ralph -n 20 "Implement feature X"

  # PRD-based workflow (recommended for projects)
  ralph --prd plans/prd.md "Read plans/prd.md and work on the next feature"

  # Custom completion signal
  ralph -p "ALL TESTS PASS" "Fix the failing tests"

  # Combined options
  ralph -n 50 --prd plans/prd.md "Complete all features in the PRD"

Note: Options must come BEFORE the prompt. Wrong: ralph "prompt" 10
EOF
}

print_header() {
  echo -e "${COLOR_GREEN}ğŸ¿ï¸  Ralph Loop${COLOR_RESET}"
  echo -e "${COLOR_BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
  echo -e "  CLI:      ${COLOR_YELLOW}$CLI${COLOR_RESET}"
  echo -e "  Max:      ${COLOR_YELLOW}$MAX_ITERATIONS${COLOR_RESET} iterations"
  echo -e "  Promise:  ${COLOR_YELLOW}$PROMISE${COLOR_RESET}"
  [[ -n "$PRD_FILE" ]] && echo -e "  PRD:      ${COLOR_YELLOW}$PRD_FILE${COLOR_RESET} (validates completion)"
  echo -e "${COLOR_BLUE}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

print_iteration_start() {
  local iteration=$1 timestamp=$2
  echo ""
  echo -e "${COLOR_YELLOW}${SEPARATOR}${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}ğŸ”„ Iteration $iteration/$MAX_ITERATIONS${COLOR_RESET}  ${COLOR_DIM}started $timestamp${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}$(render_progress_bar "$iteration" "$MAX_ITERATIONS")${COLOR_RESET}"
  echo -e "${COLOR_YELLOW}${SEPARATOR}${COLOR_RESET}"
  echo ""
  echo -e "${COLOR_DIM}â”Œâ”€â”€â”€ $CLI output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

print_iteration_end() {
  local duration_seconds=$1
  echo -e "${COLOR_DIM}â””â”€â”€â”€ completed in $(format_duration "$duration_seconds") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${COLOR_RESET}"
}

print_success() {
  local iterations=$1 total_seconds=$2
  echo ""
  echo -e "${COLOR_GREEN}${SEPARATOR}${COLOR_RESET}"
  echo -e "${COLOR_GREEN}âœ… Task complete!${COLOR_RESET}"
  echo -e "${COLOR_GREEN}   Iterations:  $iterations${COLOR_RESET}"
  echo -e "${COLOR_GREEN}   Total time:  $(format_duration "$total_seconds")${COLOR_RESET}"
  echo -e "${COLOR_GREEN}${SEPARATOR}${COLOR_RESET}"
}

print_max_iterations_reached() {
  local total_seconds=$1
  echo ""
  echo -e "${COLOR_RED}${SEPARATOR}${COLOR_RESET}"
  echo -e "${COLOR_RED}ğŸ›‘ Max iterations reached${COLOR_RESET}"
  echo -e "${COLOR_RED}   Iterations:  $MAX_ITERATIONS${COLOR_RESET}"
  echo -e "${COLOR_RED}   Total time:  $(format_duration "$total_seconds")${COLOR_RESET}"
  echo -e "${COLOR_RED}${SEPARATOR}${COLOR_RESET}"
}

print_error() {
  echo -e "${COLOR_RED}âŒ Error: $1${COLOR_RESET}" >&2
}

print_warning() {
  echo -e "${COLOR_RED}âš ï¸  $1${COLOR_RESET}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INPUT VALIDATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

validate_cli_args() {
  if [[ -z "$PROMPT" ]]; then
    print_error "No prompt provided"
    echo "  Run: ralph --help" >&2
    exit 1
  fi

  if [[ "$CLI" != "claude" && "$CLI" != "codex" ]]; then
    print_error "--cli must be 'claude' or 'codex' (got: '$CLI')"
    exit 1
  fi

  if ! [[ "$MAX_ITERATIONS" =~ ^[0-9]+$ ]]; then
    print_error "--max-iterations must be a number (got: '$MAX_ITERATIONS')"
    exit 1
  fi

  if [[ -n "$PRD_FILE" && ! -f "$PRD_FILE" ]]; then
    print_error "PRD file not found: $PRD_FILE"
    exit 1
  fi
}

check_required_commands() {
  if ! command -v "$CLI" &>/dev/null; then
    print_error "$CLI is required but not installed"
    exit 1
  fi

  # Claude streams JSON that needs parsing
  if [[ "$CLI" == "claude" ]] && ! command -v jq &>/dev/null; then
    print_error "jq is required for Claude (brew install jq)"
    exit 1
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRD VALIDATION
# Validates completion against PRD file to prevent premature signals
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Counts list items (lines starting with "- ") in the "## Offen" section
count_open_prd_items() {
  local prd_file=$1

  [[ ! -f "$prd_file" ]] && { echo "0"; return; }

  # Extract section between "## Offen" and next heading, count list items
  sed -n '/^## Offen/,/^## /p' "$prd_file" | grep -c "^- " 2>/dev/null || echo "0"
}

# Returns 0 (success) if completion is valid, 1 if rejected
validate_prd_allows_completion() {
  # Skip validation if no PRD specified
  [[ -z "$PRD_FILE" ]] && return 0

  local open_count
  open_count=$(count_open_prd_items "$PRD_FILE")

  if [[ "$open_count" -gt 0 ]]; then
    print_warning "Completion rejected: PRD has $open_count open item(s)"
    echo -e "${COLOR_DIM}   File: $PRD_FILE${COLOR_RESET}"
    return 1
  fi

  return 0
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROMPT CONSTRUCTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Wraps user prompt with iteration context and instructions
build_iteration_prompt() {
  local iteration=$1
  cat <<EOF
$PROMPT

---
ğŸ”„ Ralph iteration $iteration/$MAX_ITERATIONS

INSTRUCTIONS:
- Check files and git history for previous work
- Continue from where the last iteration left off
- When GENUINELY complete, output: <promise>$PROMISE</promise>
- Do NOT output the promise unless the statement is TRUE
EOF
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CLI EXECUTION
# Each CLI has different output formats and requires different handling
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Claude outputs streaming JSON - we parse it to show readable text
execute_claude() {
  local prompt=$1

  # Process JSON stream line by line
  # Using process substitution to capture exit code separately
  while IFS= read -r line; do
    local msg_type
    msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null)

    case "$msg_type" in
      assistant)
        # Extract text content from assistant messages
        local text
        text=$(echo "$line" | jq -r '
          .message.content[]? | select(.type == "text") | .text // empty
        ' 2>/dev/null)

        if [[ -n "$text" ]]; then
          printf "%s\n" "$text"
          printf "%s\n" "$text" >> "$OUTPUT_FILE"
        fi

        # Show tool usage for visual feedback
        local tool_name
        tool_name=$(echo "$line" | jq -r '
          .message.content[]? | select(.type == "tool_use") | .name // empty
        ' 2>/dev/null)
        [[ -n "$tool_name" ]] && echo -e "${COLOR_BLUE}  âš™ï¸  ${tool_name}${COLOR_RESET}"
        ;;
      result)
        echo -e "${COLOR_BLUE}  â†³ done${COLOR_RESET}"
        ;;
    esac
  done < <(
    claude -p --verbose --output-format stream-json --dangerously-skip-permissions -- "$prompt"
    echo $? > "$EXIT_CODE_FILE"
  )
}

# Codex outputs plain text - just tee to file
execute_codex() {
  local prompt=$1
  codex exec --yolo "$prompt" 2>&1 | tee "$OUTPUT_FILE"
  echo "${PIPESTATUS[0]}" > "$EXIT_CODE_FILE"
}

# Dispatcher - routes to appropriate CLI handler
execute_cli() {
  local prompt=$1
  if [[ "$CLI" == "claude" ]]; then
    execute_claude "$prompt"
  else
    execute_codex "$prompt"
  fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMPLETION DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Checks if CLI output contains the completion promise
output_contains_promise() {
  grep -qF "<promise>$PROMISE</promise>" "$OUTPUT_FILE"
}

get_cli_exit_code() {
  cat "$EXIT_CODE_FILE"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN ITERATION LOGIC
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Runs a single iteration, returns 0 if task completed successfully
run_iteration() {
  local iteration=$1
  local iter_start_time iter_end_time duration

  iter_start_time=$(date +%s)
  print_iteration_start "$iteration" "$(date +%H:%M:%S)"

  create_temp_files

  # Build and execute prompt
  local full_prompt
  full_prompt=$(build_iteration_prompt "$iteration")
  execute_cli "$full_prompt"

  # Show duration
  iter_end_time=$(date +%s)
  duration=$((iter_end_time - iter_start_time))
  print_iteration_end "$duration"

  # Check result
  local exit_code
  exit_code=$(get_cli_exit_code)

  if [[ "$exit_code" -ne 0 ]]; then
    print_warning "$CLI exited with error (code: $exit_code), continuing..."
    rm -f "$OUTPUT_FILE" "$EXIT_CODE_FILE"
    return 1
  fi

  # Check for completion signal
  if output_contains_promise; then
    # Validate against PRD if specified
    if validate_prd_allows_completion; then
      rm -f "$OUTPUT_FILE" "$EXIT_CODE_FILE"
      return 0  # Success - task complete
    fi
    # PRD validation failed - continue iterating
  fi

  rm -f "$OUTPUT_FILE" "$EXIT_CODE_FILE"
  return 1  # Not complete - continue iterating
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ARGUMENT PARSING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CLI="$DEFAULT_CLI"
MAX_ITERATIONS="$DEFAULT_MAX_ITERATIONS"
PROMISE="$DEFAULT_PROMISE"
PRD_FILE=""
PROMPT=""

# Track extra positional args for warning
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cli)               CLI="$2"; shift 2 ;;
    --max-iterations|-n) MAX_ITERATIONS="$2"; shift 2 ;;
    --promise|-p)        PROMISE="$2"; shift 2 ;;
    --prd)               PRD_FILE="$2"; shift 2 ;;
    --help|-h)           print_help; exit 0 ;;
    -*)                  print_error "Unknown option: $1"; exit 1 ;;
    *)
      if [[ -z "$PROMPT" ]]; then
        PROMPT="$1"
      else
        EXTRA_ARGS+=("$1")
      fi
      shift
      ;;
  esac
done

# Warn about extra positional arguments (common mistake)
if [[ ${#EXTRA_ARGS[@]} -gt 0 ]]; then
  echo -e "${COLOR_YELLOW}âš ï¸  Warning: Extra arguments ignored: ${EXTRA_ARGS[*]}${COLOR_RESET}" >&2
  echo -e "${COLOR_DIM}   Did you mean to use flags?${COLOR_RESET}" >&2

  # Detect common patterns and suggest correct syntax
  for arg in "${EXTRA_ARGS[@]}"; do
    if [[ "$arg" =~ ^[0-9]+$ ]]; then
      echo -e "${COLOR_DIM}   â€¢ For iterations: -n $arg${COLOR_RESET}" >&2
    elif [[ "$arg" =~ ^(COMPLETE|DONE|FINISHED|READY)$ ]]; then
      echo -e "${COLOR_DIM}   â€¢ For promise: -p $arg${COLOR_RESET}" >&2
    elif [[ -f "$arg" ]] || [[ "$arg" =~ \.(md|txt)$ ]]; then
      echo -e "${COLOR_DIM}   â€¢ For PRD validation: --prd $arg${COLOR_RESET}" >&2
    fi
  done

  echo "" >&2
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

main() {
  validate_cli_args
  check_required_commands
  print_header

  local total_start_time iteration total_duration
  total_start_time=$(date +%s)

  for iteration in $(seq 1 "$MAX_ITERATIONS"); do
    if run_iteration "$iteration"; then
      # Task completed successfully
      total_duration=$(($(date +%s) - total_start_time))
      print_success "$iteration" "$total_duration"
      exit 0
    fi
  done

  # All iterations exhausted without completion
  total_duration=$(($(date +%s) - total_start_time))
  print_max_iterations_reached "$total_duration"
  exit 1
}

main
